exit
input.methods.grep /load/
input.methods
input
bigger_shipment
truck
input
exit
input.load(truck.id,bigger_shipment.id)
input
exit
continue
input
continue
exit
loader.shipments_that_fit(loader.biggest_truck)
loader.shipments_that_fit(biggest_truck)
loader.biggest_shipment
loader.shipments
assert loader.biggest_shipment.capacity == 16_000
assert loader.smallest_truck.capacity == 42_000
loader.smallest_truck.capacity
loader.smallest_truck
loader.trucks
continue
exit
trucks_with_space.sort_by { |truck| truck.capacity}.first
trucks_with_space.sort { |truck| truck.capacity}.first
trucks_with_space.first.capacity
trucks_with_space
exit
combinations.first(100).map { |x| p [x.size, x.map(&:capacity).sum ] } ; nil
combinations.sort! { |a, b| [b.size, b.map(&:capacity).sum ] <=> [a.size, a.map(&:capacity).sum] }
combinations.first(100).map { |x| p [x.size, x.map(&:capacity).sum ] }
combinations.sort! { |a, b| [a.size, b.map(&:capacity).sum ] <=> [b.size, a.map(&:capacity).sum] }
combinations.first(100).map { |x| p [x.size, x.map(&:capacity).sum ] }
combinations.sort! { |a, b| [b.map(&:capacity).sum, a.size] <=> [a.map(&:capacity).sum, b.size] }
combinations.first(100).map { |x| p [x.size, x.map(&:capacity).sum ] }
combinations.sort! { |a, b| [b.size, b.map(&:capacity).sum ] <=> [a.size, a.map(&:capacity).sum ] }
combinations.sort! { |a, b| [b.size, b.map(&:capacity).sum ] <=> [a.size, a.map(&:capacity).sum ] 
combinations.size
combinations
combinations.first(100).map { |x| [x.size, x.map(&:capacity).sum ] }
combinations.first(10).map { |x| [x.size, x.map(&:capacity).sum ] }
combinations.first.count
combinations.first
combinations.first.size
combinations.first(10).map {|x| [x.siz
combinations.first
continue
exit
require 'ltl_packer'
exit
require 'ltl_packer'
exit
LtlPacker::Shipment
LtlPacker::Shipment.class
LtlPacker.class
LtlPacker
LtlPacker::Shipment.new(1,2)
require 'ltl_packer'
exit
require 'ltl_packer'
exit
require 'ltl_packer'
exit
require 'ltl_packer'
require 'ltl_packer/shipment'
require 'ltl_packer/loader'
require 'ltl_packer/truck'
require 'ltl_packer/version'
require 'ltl_packer/shipment'
require 'ltl_packer'
exit
loader.shipments.count
continue
best_combination.count
best_combinations.count
loader.shipments.count
best_combination
continue
best_combination
continue
best_combination
continue
best_combination
continue
best_combination
continue
best_combination
exit
combinations.first.map(&:capacity).sum
combinations.first
combinations.sort! { |a, b| b.map(&:capacity).sum <=> a.map(&:capacity).sum } 
combinations.last
combinations.first
combinations
conbinations.first
combinations.size
exit
next
step
next
loader.biggest_shipment
next
step
loader.done?
loader
continue
finished_loader.shipments.size
finished_loader.trucks.map(&:cargo_count).sum
finished_loader.trucks.map(&:cargo_count)
finished_loader.trucks.map(&:cargo_size)
finished_loader.shipments.size
finished_loader.shipments
finished_loader
continue
exit
loader.shipments.size
loader.shipments
loader
exit
trucks.map(&:cargo_count)
shipments.count
exit
shipments
trucks.map(&:cargo_count)
trucks
shipments
exit
loader.biggest_shipment.capacity
loader.smallest_truck.capacity
loader.smallest_truck
loader.shipments
loader.trucks
exit
loader.smallest_truck
loader.trucks
loader
exit
this_solution.trucks.map(&:cargo).size
this_solution.trucks.map(&:cargo)
this_solution.trucks
this_solution.trucks.map(&:cargo).max 
step
exit
trucks.max_by(&:capacity)
trucks.first.capacity
trucks
trucks.max { |truck| truck.capacity}.capacity
trucks.max { |truck| truck.capacity}
this_solution.done?
this_solution.shipments.count
this_solution.shipments
this_solution.cargo
this_solution.cargo'
this_solution.done?
this_solution.trucks
this_solution
step
this_solution
s
step
solved.size
s
s.done?
s.trucks
s.trucks.map(&:cargo)
exit
trucks
shipments
self.shipments
self.class
self.clas
selc.class
self
trucks
shipments
exit
best.shipments.sum(&:capacity)
best
continue
exit
trucks.map(&:cargo).flatten.count
continue
exit
trucks
continue
exit
x = solved.min_by { |s| s.shipments.count } ;[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
x.shipments.count
x.shipments
x = solved.min_by { |s| s.unshipped_capacity } ;[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
continue
@shipments.values.sum
@shipments.values
@trucks
exit
44000 + 42000 + 20000 + 24000
trucks.sum {|t| t.capacity }
49300 + 95700
shipments.sum {|s| s.capacity } - trucks.sum {|t| t.capacity }
shipments.sum {|s| s.capacity } = trucks.sum {|t| t.capacity }
trucks.sum {|t| t.capacity }
shipments.sum {|s| s.capacity }
shipments.sum {|s| sl.capacity }
shipments.sum {|s| sl.capacity
shipments
shipment
103000 - 7300
x = solved.min_by { |s| s.unshipped_capacity } ;[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
x = solved.min_by { |s| s.unshipped_count } ;[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
exit
y.size
y = solved.select { |argh| argh.wasted_space == 3800 }
y = x.select { |argh| argh.wasted_space == 3800 }
x.wasted_space
x.unshipped_capacity
x.trucks.map {|t| [t.cargo.size,t.cargo.map {|c| [ c.id, c.capacity ] }]}
x.trucks.map {|t| [t.cargo.size,t.cargo.map(&:capacity)]}
x.trucks.map {|t| t.cargo.size}
x.shipments.size
x.shipments
x = solved.min_by { |s| s.unshipped_capacity } ;[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
x = solved.max { |s| s.unshipped_capacity } ;[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
x.done?
x = solved.min { |s| s.unshipped_capacity } ;[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
x = solved.max { |s| s.unshipped_capacity } ;[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
exit
x = solved.max { |s| s.unshipped_capacity } ;[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
exit
x = solved.max { |s| s.unshipped_capacity } ;[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
exit
x = solved.max { |s| s.unshipped_capacity } ;[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
[x.wasted_space, x.unshipped_capacity, x.unshipped_count]
[x.wasted_space, x.unshipped_capacity, x.unshipped_count[
x = solved.max { |s| s.unshipped_capacity }
exit
x.unshipped_count
x.unshipped_capacity
x.wasted_space
x = solved.max { |s| s.unshipped_capacity }
exit
x.unshipped_count
x.unshipped_capacity
x.wasted_space
x = solved.max { |s| s.unshipped_capacity }
exit
x.unshipped_count
x.unshipped_capacity
x.wasted_space
x = solved.max { |s| s.unshipped_capacity }
exit
continue
exit
shipments_that_fit(truck.capacity)
